/*
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation; either version 2, or (at your option)
 *  any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with this program; if not, write to the Free Software
 *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */

#ifndef _MEMLOCDATA_H_
#define _MEMLOCDATA_H_

#include "types.h"
#include "i_projectmodel.h"
#include "xrefmanager.h"


class I_ProjectModel;
/**
 * \brief MemlocData is the data the I_ProjectModel class has on a location specified by an address_t
 *
 * Each analyzed memory location is associated with an instantiation of a subclass of MemlocData.
 * MemlocData is an interface and cannot be used directly
 */
class MemlocData {
public:
	virtual ~MemlocData();
	
	/**
	 * \brief Get the address of the start of this memory location information
	 * @return the start address of this data
	 */
	address_t	get_addr() const;
	
	/**
	 * \brief get a pointer to the previous contiguous MemlocData
	 * @return a pointer to the previous MemlocData, or NULL if none could be found
	 */
	MemlocData *  getPreviousContiguous();
	
	/**
	 * \brief get a pointer to the next contiguous MemlocData
	 * @return a pointer to the next MemlocData, or NULL if none could be found
	 */
	MemlocData *  getNextContiguous();
	
	/** 
	 * \brief Get the length of this memory location datablock
	 * @return the length of this memory location
	 */
	virtual u32	get_length() const = 0;
	
	/**
	 * @return whether the memloc continues to the next memlocdata [see getNextContiguous() ]
	 */
	virtual bool logically_continues() const = 0;
	
	/**
	 * @return if the memlocdata is executable
	 */
	virtual bool is_executable() const = 0;
	
	/**
	 * @return begin iterator of the xrefs to this memory location
	 */
	XrefManager::xref_map_ci begin_xref_to() const;
	
	/**
	 * @return end iterator of the xrefs to this memory location
	 */
	XrefManager::xref_map_ci end_xref_to() const;
	
	/**
	 * @return count of the xrefs to this memory location
	 */
	u32			 count_xrefs_to() const;
	
	/**
	 * @return if there are any xrefs to this memory location [may be faster than count_ ]
	 */
	bool		 has_xrefs_to() const;
	
	/**
	 * @return begin iterator of the xrefs from this memory location
	 */
	XrefManager::xref_map_ci begin_xref_from() const;

	/**
	 * @return end iterator of the xrefs from this memory location
	 */
	XrefManager::xref_map_ci end_xref_from() const;
	
	/**
	 * @return count of the xrefs from this memory location
	 */
	u32			 count_xrefs_from() const;
	
	/**
	 * @return if there are any xrefs from this memory location [may be faster than count_ ]
	 */
	bool		 has_xrefs_from() const;
	
	/**
	 * @return Pointer to the symbol of this memory location, NULL if none
	 */
	const Symbol * get_symbol() const;
	
	/**
	 *	@return a textual representation of this memory data
	 */
	virtual const std::string get_textual() = 0;
	
	/**
	 *	\brief mark this memory loc data as explicitly defined, aka, not autogenerated. This is so autogenerated data
	 * can be erased when the original creator is gone
	 */
	void		mark_explicit(bool mark);
	
	/**
	 * @return if this memory loc was created explicitly
	 */
	bool		get_explicit() const;
	
	/**
	 * @return the DataType that this memory location is. may return null now, but not in the future
	 */
	const DataType * getCreatingDataType() const;
	
	/**
	 * @return the trace that this ctx belongs to
	 */
	const I_ProjectModel * get_ctx() const;

	/** 
	 * \brief Create a new memoryloc
	 * @param creator the creating datatype
	 * @param ctx the trace to own this memoryloc
	 * @param addr the star address of this memory location info
	 * @param length the length of this memory location info
	 */
	MemlocData(const DataType * creator, const I_ProjectModel * ctx, address_t addr, u32 length);
protected:
	
private:
	
	const I_ProjectModel * m_ctx;
	
	MemlocData * m_prev;
	MemlocData * m_next;
	
	// If the address has been explicitly defined
	bool m_explicit;
	
	// Common variables
	const address_t m_address;

	const DataType * m_creator;
	
	friend class I_ProjectModel;

};

#endif

